<!DOCTYPE html>
<html>
<head>
	<title>Polished Crystal Save Patcher</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
		/* Updated CSS with progress bar removed */
		body {
			font-family: Arial, sans-serif;
			margin: 0;
			background-color: #121212;
			color: #e0e0e0;
		}
		h1 {
			color: #b39ddb;
			text-align: center;
			padding-top: 20px;
		}
		.container {
			max-width: 800px;
			margin: 20px auto;
			padding: 20px;
			background-color: #1e1e1e;
			border: 1px solid #333;
			box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
		}
		.instructions {
			margin-bottom: 20px;
			line-height: 1.6;
		}
		input[type="file"] {
			margin-bottom: 10px;
			background-color: #2e2e2e;
			color: #e0e0e0;
			border: 1px solid #555;
			padding: 10px;
			width: 100%;
			box-sizing: border-box;
			cursor: pointer;
		}
		button, select {
			background-color: #673ab7;
			color: #ffffff;
			border: none;
			padding: 12px 20px;
			font-size: 16px;
			cursor: pointer;
			margin-bottom: 20px;
			width: 100%;
			box-sizing: border-box;
			border-radius: 4px;
			transition: background-color 0.3s ease;
		}
		button:hover, select:hover {
			background-color: #5e35b1;
		}
		button:disabled {
			background-color: #555;
			cursor: not-allowed;
		}
		pre {
			background-color: #1e1e1e;
			border: 1px solid #333;
			padding: 10px;
			overflow: auto;
			white-space: pre-wrap;
			word-wrap: break-word;
			max-height: 300px;
			line-height: 1.2;
			margin: 0;
			font-family: monospace;
			font-size: 14px;
			color: #e0e0e0;
		}
		.warning {
			color: #ffcc00;
		}
		.error {
			color: #ff6e6e;
		}
		#indicator.error {
			color: #ff6e6e;
		}
		#indicator {
			color: #b39ddb;
			font-weight: bold;
			margin-bottom: 20px;
			text-align: center;
		}
		.tooltip {
			position: relative;
			display: inline-block;
			background-color: #333;
			padding: 2px 4px;
			border-radius: 3px;
		}
		.tooltip .tooltiptext {
			visibility: hidden;
			width: 200px;
			background-color: #555;
			color: #fff;
			text-align: center;
			border-radius: 6px;
			padding: 5px;
			position: absolute;
			z-index: 1;
			bottom: 125%;
			left: 50%;
			margin-left: -100px;
			opacity: 0;
			transition: opacity 0.3s;
		}
		.tooltip .tooltiptext::after {
			content: "";
			position: absolute;
			top: 100%;
			left: 50%;
			margin-left: -5px;
			border-width: 5px;
			border-style: solid;
			border-color: #555 transparent transparent transparent;
		}
		.tooltip:hover .tooltiptext {
			visibility: visible;
			opacity: 1;
		}
		@media (max-width: 600px) {
			h1 {
				font-size: 24px;
			}
			button, select {
				font-size: 14px;
			}
		}
	</style>
	<script src="polished_save_patcher.js"></script>
</head>
<body>
	<div class="container">
		<h1>Polished Crystal Save Patcher</h1>
		<div class="instructions">
			<p>
				This tool allows you to patch your Polished Crystal save files between various versions.
				Follow the steps below to patch your save file:
			</p>
			<ol>
				<li>Save your game on the second floor of the <span class="tooltip">Mon Healing Center P.C.
					<span class="tooltiptext"><img src="https://tcrf.net/images/7/76/PokemonCrystal_PokeCenter_2F_International.png" alt="Mon Healing Center P.C." width="200"></span>
				</span> (Where you normally do link battles/trades)</li>
				<li>Back up your original save file somewhere safe.</li>
				<li>Click the "Choose File" button to select your old save file.</li>
				<li>Click the "Upload Save" button to upload your save file and display the current save version.</li>
				<li>Select your target save version from the dropdown menu (default is the highest version).</li>
				<li>Click the "Patch Save" button to start the patching process.</li>
				<li>Once the patching is complete, a new save file will be downloaded automatically.</li>
				<li>If the download doesn't start automatically, click the "Download Patched Save" button.</li>
				<li>After loading your patched save for the first time, promptly exit the Pok√©mon Center before interacting with anything.</li>
			</ol>
		</div>
		<input type="file" id="oldSave" />
		<button onclick="uploadSave()" id="uploadButton" disabled>Upload Save</button>
		<div id="currentVersion"></div>
		<select id="targetVersion">
			<option value="9" selected>Version 9 (3.1.0)</option>
			<option value="8">Version 8 (3.0.0)</option>
		</select>
		<button onclick="patchSave()" id="patchButton" disabled>Patch Save</button>
		<div id="indicator">Initializing...</div>
		<pre id="output"></pre>
		<button id="manualDownloadButton" onclick="manualDownload()" disabled>Download Patched Save</button>
		<button onclick="downloadLog()">Download Log</button>
	</div>

	<script>
		// Disable buttons until the module is initialized
		document.getElementById('uploadButton').disabled = true;
		document.getElementById('patchButton').disabled = true;
		document.getElementById('manualDownloadButton').disabled = true;

		let patchedBlobUrl = null;
		let logMessages = [];

		function logMessage(message, type = 'info') {
			const outputElement = document.getElementById('output');
			const timestamp = new Date().toLocaleTimeString();
			const formattedMessage = `[${timestamp}] ${message}`;
			logMessages.push(formattedMessage);

			const messageElement = document.createElement('div');
			messageElement.textContent = formattedMessage;
			if (type === 'error') {
				messageElement.classList.add('error');
			} else if (type === 'warning') {
				messageElement.classList.add('warning');
			}
			outputElement.appendChild(messageElement);
			outputElement.scrollTop = outputElement.scrollHeight;
		}

		// Wait for the Module to be fully initialized
		if (typeof Module !== 'undefined') {
			Module.onRuntimeInitialized = onModuleInitialized;
		} else {
			// If Module is not yet defined, wait for it
			window.addEventListener('load', function() {
				Module.onRuntimeInitialized = onModuleInitialized;
			});
		}

		function onModuleInitialized() {
			document.getElementById('uploadButton').disabled = false;
			logMessage('Module initialized successfully.');
			document.getElementById('indicator').textContent = 'Ready to patch.';
		}

		function uploadSave() {
			const oldSaveFile = document.getElementById('oldSave').files[0];
			if (!oldSaveFile) {
				alert("Please select the save file you want to upload.");
				return;
			}

			const reader = new FileReader();
			reader.onload = function(event) {
				const data = new Uint8Array(event.target.result);

				// Ensure FS is available
				if (typeof FS === 'undefined') {
					logMessage('File system not initialized.', 'error');
					return;
				}

				FS.writeFile('/old_save.sav', data);
				try {
					const saveVersion = Module.get_save_version('/old_save.sav');
					if (saveVersion) {
						document.getElementById('currentVersion').textContent = 'Current Save Version: ' + saveVersion.toString(16);
						document.getElementById('patchButton').disabled = false; // Enable the Patch Save button
						logMessage('Save file uploaded successfully. Version: ' + saveVersion.toString(16));
					} else {
						document.getElementById('currentVersion').textContent = 'Invalid save file.';
						document.getElementById('patchButton').disabled = true; // Disable the Patch Save button
						logMessage('Invalid save file.', 'error');
					}
				} catch (e) {
					document.getElementById('currentVersion').textContent = 'Error reading save file.';
					document.getElementById('patchButton').disabled = true;
					logMessage('Error reading save file: ' + e.message, 'error');
				}
			};
			reader.readAsArrayBuffer(oldSaveFile);
		}

		function patchSave() {
			const oldSaveFile = document.getElementById('oldSave').files[0];
			const targetVersion = parseInt(document.getElementById('targetVersion').value, 10);
			if (!oldSaveFile) {
				alert("Please select the save file you want to patch.");
				return;
			}

			const indicatorElement = document.getElementById('indicator');
			const outputElement = document.getElementById('output');
			const patchButton = document.getElementById('patchButton');
			const manualDownloadButton = document.getElementById('manualDownloadButton');

			// Clear previous output and update indicator
			outputElement.textContent = '';
			logMessages = [];
			indicatorElement.textContent = 'Patching in progress...';
			indicatorElement.classList.remove('error');
			patchButton.disabled = true;
			manualDownloadButton.disabled = true;

			const oldSavePath = '/old_save.sav';
			const newSavePath = '/new_save.sav';

			if (FS.analyzePath(newSavePath).exists) {
				FS.unlink(newSavePath);
			}

			const reader = new FileReader();
			reader.onload = function(event) {
				const data = new Uint8Array(event.target.result);
				FS.writeFile(oldSavePath, data);

				// Call the C++ function and handle the result
				try {
					const result = Module.patch_save(oldSavePath, newSavePath, targetVersion);
					if (result.success) {
						const patchedData = FS.readFile(newSavePath, { encoding: 'binary', flags: 'r' });
						if (patchedData) {
							if (patchedBlobUrl) {
								URL.revokeObjectURL(patchedBlobUrl);
							}
							const blob = new Blob([patchedData], { type: 'application/octet-stream' });
							patchedBlobUrl = URL.createObjectURL(blob);
							const a = document.createElement('a');
							a.href = patchedBlobUrl;
							a.download = 'patched_save.sav';
							a.click();

							indicatorElement.textContent = 'Patching complete. Save file downloaded successfully.';
							indicatorElement.classList.remove('error');
							manualDownloadButton.disabled = false;
							logMessage('Patching completed successfully.');
						} else {
							indicatorElement.textContent = 'Patching complete with errors. Failed to read the patched save file.';
							indicatorElement.classList.add('error');
							logMessage('Failed to read the patched save file.', 'error');
						}
					} else {
						indicatorElement.textContent = 'Patching failed. See errors in the output.';
						indicatorElement.classList.add('error');
						logMessage('Patching failed.', 'error');
					}
				} catch (e) {
					indicatorElement.textContent = 'An error occurred during patching.';
					indicatorElement.classList.add('error');
					logMessage('Error during patching: ' + e.message, 'error');
				}
				patchButton.disabled = false;
			};
			reader.readAsArrayBuffer(oldSaveFile);
		}

		function manualDownload() {
			if (patchedBlobUrl) {
				const a = document.createElement('a');
				a.href = patchedBlobUrl;
				a.download = 'patched_save.sav';
				a.click();
			}
		}

		function downloadLog() {
			const logContent = logMessages.join('\n');
			const blob = new Blob([logContent], { type: 'text/plain' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = 'patch_log.txt';
			a.click();
			URL.revokeObjectURL(url);
		}
	</script>
</body>
</html>
